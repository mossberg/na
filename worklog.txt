## 2/8

- starting this dumb memory allocator bc i don't know how to write them.
  though it might be fun to try to write it organically rather than looking up
  how to do it
- first one is going to be so dumb. will only support alloc(). no realloc, free
  etc
- api
    - init
        - mmaps region
    - alloc
        - return memory
    - close
        - munmap
- allocator will have state. basically just a pointer to the start of the
  free section. that pointer will get bumped on every malloc call. how to
  check if we've exceeded pagesize space?
    - well i guess we can keep a total allocated state variable and check that
      on every alloc.
    - or just in the init, save the address of the last valid address of the
      mapping and compare that. i'll do this
- ok so i had that basic impl down
    - now i want to think about how to add a free function
- what are the semantics of `free`? it's telling the allocator that the
  memory is now available to be used by something else. my dumb allocator
  fundamentally can't support this since it's only state is a pointer to
  the free section of memory
- this leads me to believe that i'll need this chunk idea. where the heap is
  composed of discrete chunks of memory.
- a chunk has a header right before it, and the header tells how large the
  mem space is.
- when we initialize the heap, we mmap the region, and then set the header of
  the beginning of the map to say that this is an unallocated chunk


chunk struct
- we'll need a bit in the header for whether the chunk is allocated or not
- need a bit for whether this is the end of the list?


- then our alloc function will traverse across the heap looking for the first
  chunk who is unallocated and has a good enough size.
- ultimately the end of this list will be a chunk that's the last chunk and
  represents the end of the heap. so the heap will effectively start out as a
  single unallocated chunk


--

- cool, so i have a minimal working memory allocator. it implements an alloc
  and free function. the alloc function allows n bytes of memory and returns
  a pointer to it, to be used by the caller. the free function is given
  a pointer to that data and marks that data as now reusable. the allocator
  then is able to reuse that space if appropriate
- next steps
    - chunk coalescing
    - questions
        - security regarding freed blocks. memset the data that was there?
            - otherwise if you mallocd and read that data you would see whatever
              was there before, idk
        - unallocated block of size 8. they call alloc of size 5, which fits
          into that unallocated block. what is the size for that chunk?
          rn it stays at 8. i guess changing it to 5 would introduce a gap in
          the heap. at the moment the heap is entirely adjacent
